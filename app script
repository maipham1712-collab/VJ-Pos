// ═══════════════════════════════════════════════════════════
// VJ-POS Google Apps Script API v2.1.1 (Hardened + Stock Check)
// ═══════════════════════════════════════════════════════════
//
// MỤC TIÊU BẢN NÀY:
// 1) Luôn trả JSON (kể cả khi lỗi / exception) => frontend không bị "mù lỗi"
// 2) Có endpoint GET action=ping và action=schema để test nhanh
// 3) Dùng LockService chống trùng orderId khi submit đồng thời
// 4) Đọc/ghi theo HEADER (có fallback theo index) để chống lệch cột
// 5) KIỂM TRA TỒN KHO trước khi bán – nếu không đủ, trả lỗi ngay
// 6) voidOrder dùng header map thay vì index cứng
// 7) bulkImport dùng getMaxColumns() thay getLastColumn() để an toàn
//
// DEPLOY:
// Extensions → Apps Script → dán đè toàn bộ Code.gs → Save
// Deploy → Manage deployments → Edit → Version: New → Deploy
//
// LƯU Ý CORS:
// Frontend hiện tại đang POST mà KHÔNG set Content-Type => tránh preflight.
// ĐỪNG tự ý thêm headers Content-Type: application/json ở frontend (sẽ dễ dính CORS).
// ═══════════════════════════════════════════════════════════

const SS = SpreadsheetApp.getActiveSpreadsheet();

const API_VERSION = "2.1.2";
const TZ = Session.getScriptTimeZone();

// Service type detection (giữ như v2.0)
const SERVICE_TYPES = ["Service", "GRILLZ", "TOOTHGEM", "TOOTHCHARM", "Dịch vụ"];

// ===== Schema expectations (dùng cho action=schema) =====
const SCHEMA = {
  Admin_Staff: {
    requiredAnyOf: {
      staff_id: ["staff_id","id","staffid"],
      name: ["name","staff_name","staffname"],
      role: ["role","staff_role","staffrole"],
      active: ["active","is_active","enabled"],
      pin: ["pin","staff_pin","staffpin"],
    },
  },

  Admin_Products: {
    requiredAnyOf: {
      product_id: ["product_id","id","productid"],
      loai_hang: ["loai_hang","type","loaihang"],
      nhom_hang: ["nhom_hang","cat","category","nhomhang","group"],
      ten_hang: ["ten_hang","ten_hàng","tenhang"],
      brand: ["brand_id","brand","thuong_hieu","thương_hiệu"],
      price: ["gia_ban","price","giaban"],
      cost: ["gia_von","cost","giavon"],
      qty: ["qty_on_hand","ton_kho","qty","tonkho"],
      img: ["image_url","img","image","imageurl"],
      active: ["active","is_active","enabled"],
    },
  },

  Orders: {
    requiredAnyOf: {
      order_id: ["order_id","orderid","id"],
      date: ["order_date","date","created_at","created","datetime"],
      staff_id: ["staff_id","staffid"],
      customer_name: ["customer_name","cust_name","name"],
      customer_phone: ["customer_phone","cust_phone","phone"],
      subtotal: ["base_cost_total","subtotal"],
      item_disc_total: ["discount_total","item_disc_total","item_discount_total"],
      bill_disc_amt: ["bill_disc_amt","bill_discount_amount","bill_disc_amount","bill_disc"],
      bill_disc_pct: ["bill_disc_pct","bill_discount_pct","bill_disc_percent","bill_disc_percent"],
      card_fee_amt: ["card_fee_amt","card_fee","card_fee_amount","fee_card"],
      ship_amt: ["ship_amt","shipping","ship_amount","delivery_fee","ship"],
      notes: ["notes","note"],
      net_comm_base: ["net_commission_base","net_comm_base"],
      extra_fee_total: ["extra_fee_total","extra_fee","fee_total"],
      grand_total: ["grand_total","total"],
      collected_total: ["collected_total"],
      collected_for_commission: ["collected_for_commission"],
      payment_status: ["payment_status"],
      commission_paid_total: ["commission_paid_total"],
      status: ["status"],
    },
  },

  Order_Items: {
    requiredAnyOf: {
      line_item_id: ["order_item_id","line_item_id","lineitem_id","id"],
      order_id: ["order_id","orderid"],
      product_id: ["product_id","productid"],
      name: ["product_name","name"],
      brand: ["brand_id","brand"],
      cat: ["cat","nhom_hang","category","nhomhang","group"],
      qty: ["qty","quantity"],
      unit_price: ["unit_price","price"],
      line_base_cost: ["line_base_cost"],
      discount: ["line_discount_amount","discount","disc"],
      line_net: ["line_net_commission_base","line_net","net"],
      staff_id: ["staff_id","staffid"],
      rate: ["staff_commission_rate","rate"],
      comm_full: ["commission_full","comm_full"],
      comm_paid: ["commission_paid","commiss_paid","commission_paid_amount"],
    },
  },

  Payments: {
    requiredAnyOf: {
      payment_id: ["payment_id","paymentid","id"],
      order_id: ["order_id","orderid"],
      date: ["payment_date","date","created_at","created"],
      method: ["method"],
      amount: ["amount_total","amount"],
      amount_for_comm: ["amount_for_commission","amount_for_comm","amount_comm"],
      note: ["note","notes"],
    },
  },

  Admin_Artists: {
    requiredAnyOf: {
      id: ["artist_id","id","brand_id","brand"],
      name: ["name"],
      type: ["type"],
      rate: ["commission_rate_to_staff","rate"],
      active: ["active","is_active","enabled"],
    },
  },

  Admin_Stock_Log: {
    requiredAnyOf: {
      log_id: ["log_id","id"],
      date: ["timestamp","date","created_at","created"],
      product_id: ["product_id","productid"],
      change_type: ["change_type","type"],
      qty_change: ["qty_change","qtychange"],
      qty_before: ["qty_before","qtybefore"],
      qty_after: ["qty_after","qtyafter"],
      reference: ["reference","ref"],
      changed_by: ["changed_by","by"],
    },
  },
};

// ===== Entry points =====
function doGet(e) {
  const reqId = _reqId_();
  const params = (e && e.parameter) ? e.parameter : {};
  const action = String(params.action || "").toLowerCase().trim();

  return _handle_(reqId, "GET", action, () => {
    switch (action) {
      case "ping": return _ok_({ msg: "pong", version: API_VERSION });
      case "schema": return schemaReport();
      case "products": return getProducts();
      case "staff": return getStaffPublic();
      case "artists": return getArtists();
      case "orders": return getOrders();
      case "login": return login(params.pin || "");
      default:
        return _ok_({ msg: "VJ-POS API", version: API_VERSION, actions: ["ping","schema","products","staff","artists","orders","login"] });
    }
  });
}

function doPost(e) {
  const reqId = _reqId_();

  // Parse JSON body (frontend hiện tại gửi raw JSON string, không set headers)
  const raw = (e && e.postData && typeof e.postData.contents === "string") ? e.postData.contents : "";
  const body = _tryParseJson_(raw);
  if (!body.ok) return _json_(_err_("Invalid JSON", { detail: body.error, rawHead: raw.slice(0, 120) }, reqId));

  const action = String(body.value.action || "").toLowerCase().trim();

  // Bypass auth cho ping/schema nếu ai đó POST test
  if (action === "ping") return _json_(_ok_({ msg: "pong", version: API_VERSION }, reqId));
  if (action === "schema") return _json_(schemaReport(reqId));

  // Validate PIN for all write operations
  const pin = String(body.value.pin || "").trim();
  const auth = _validatePin_(pin);
  if (!auth) return _json_(_err_("Invalid PIN", null, reqId));

  // Inject authenticated staff info (giữ tương thích v2.0)
  body.value.staffId = auth.id;
  body.value.staffName = auth.name;
  body.value.staffRole = auth.role;

  return _handle_(reqId, "POST", action, () => {
    switch (action) {
      case "submit_order": return submitOrder(body.value);
      case "add_payment": return addPayment(body.value);
      case "update_stock": return updateStock(body.value);
      case "void_order": return voidOrder(body.value);
      case "bulk_import": return bulkImport(body.value);
      default:
        return _err_("Unknown action: " + action, null, reqId);
    }
  });
}

// ===== Response helpers =====
function _json_(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

function _ok_(data, reqId) {
  const out = data || {};
  out.ok = true;
  out.version = API_VERSION;
  out.ts = _nowStr_();
  if (reqId) out.reqId = reqId;
  return out;
}

function _err_(message, extra, reqId) {
  const out = { ok: false, error: String(message || "Error"), version: API_VERSION, ts: _nowStr_() };
  if (reqId) out.reqId = reqId;
  if (extra) out.extra = extra;
  return out;
}

function _handle_(reqId, method, action, fn) {
  try {
    const res = fn();
    // nếu fn trả object không có ok, bọc thành ok
    if (res && typeof res === "object" && res.ok === undefined) return _json_(_ok_(res, reqId));
    if (res && typeof res === "object" && res.reqId === undefined) res.reqId = reqId;
    return _json_(res);
  } catch (err) {
    return _json_(_err_(err && err.message ? err.message : String(err), { method, action }, reqId));
  }
}

function _reqId_() {
  try { return Utilities.getUuid(); } catch (_) { return "REQ-" + new Date().getTime(); }
}

function _nowStr_() {
  return Utilities.formatDate(new Date(), TZ, "yyyy-MM-dd HH:mm:ss");
}

function _tryParseJson_(s) {
  try {
    if (!s) return { ok: false, error: "Empty body" };
    return { ok: true, value: JSON.parse(s) };
  } catch (e) {
    return { ok: false, error: e.message || String(e) };
  }
}

function _asNum_(v, def) {
  const n = Number(v);
  return Number.isFinite(n) ? n : (def || 0);
}

function _isFalse_(v) {
  return v === false || v === 0 || String(v).toUpperCase() === "FALSE";
}

// ===== Sheet helpers (header map + fallback) =====
function _sheet_(name) {
  const ws = SS.getSheetByName(name);
  if (!ws) throw new Error("Missing sheet: " + name);
  return ws;
}

function _headers_(ws) {
  const lastCol = Math.max(1, ws.getLastColumn());
  const row = ws.getRange(1, 1, 1, lastCol).getValues()[0] || [];
  return row.map(h => String(h || "").trim().toLowerCase());
}

function _hmap_(ws) {
  const hs = _headers_(ws);
  const map = {};
  for (let i = 0; i < hs.length; i++) if (hs[i]) map[hs[i]] = i;
  return map;
}

// find a column index by trying a list of header names
function _col_(hmap, names) {
  for (const n of names) {
    const key = String(n || "").trim().toLowerCase();
    if (key && hmap[key] !== undefined) return hmap[key];
  }
  return -1;
}

// ----- Thêm helper ghi theo header -----
function _appendByHeader_(ws, obj) {
  const map = _hmap_(ws);
  const row = new Array(ws.getLastColumn()).fill("");
  for (const k in obj) {
    const key = String(k).trim().toLowerCase();
    if (map[key] !== undefined) row[map[key]] = obj[k];
  }
  ws.appendRow(row);
}

function _findRowByHeader_(ws, headerVariants, value) {
  const h = _hmap_(ws);
  const c = _col_(h, headerVariants);
  if (c < 0) return -1;
  const lastRow = ws.getLastRow();
  if (lastRow < 2) return -1;
  const colVals = ws.getRange(2, c + 1, lastRow - 1, 1).getValues();
  for (let i = 0; i < colVals.length; i++) {
    if (String(colVals[i][0]) === String(value)) return i + 2;
  }
  return -1;
}
// ----- Kết thúc helper -----

// ===== AUTH =====
function _validatePin_(pin) {
  if (!pin) return null;
  const ws = _sheet_("Admin_Staff");
  const h = _hmap_(ws);
  const data = ws.getDataRange().getValues();

  // Header-based (preferred)
  const cId = _col_(h, SCHEMA.Admin_Staff.requiredAnyOf.staff_id);
  const cName = _col_(h, SCHEMA.Admin_Staff.requiredAnyOf.name);
  const cRole = _col_(h, SCHEMA.Admin_Staff.requiredAnyOf.role);
  const cActive = _col_(h, SCHEMA.Admin_Staff.requiredAnyOf.active);
  const cPin = _col_(h, SCHEMA.Admin_Staff.requiredAnyOf.pin);

  // Fallback to v2.0 indexes: A=id, B=name, C=role, D=active, E=pin
  const fId = 0, fName = 1, fRole = 2, fActive = 3, fPin = 4;

  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const id = (cId >= 0) ? row[cId] : row[fId];
    if (!id) continue;

    const active = (cActive >= 0) ? row[cActive] : row[fActive];
    if (_isFalse_(active)) continue;

    const staffPin = String((cPin >= 0) ? row[cPin] : row[fPin] || "").trim();
    if (staffPin && staffPin === String(pin).trim()) {
      return {
        id: String(id),
        name: String((cName >= 0) ? row[cName] : (row[fName] || "")),
        role: String((cRole >= 0) ? row[cRole] : (row[fRole] || "")),
      };
    }
  }
  return null;
}

function login(pin) {
  const auth = _validatePin_(String(pin || "").trim());
  if (!auth) return _err_("Invalid PIN");
  return { ok: true, staff: auth, version: API_VERSION, ts: _nowStr_() };
}

function _isService_(loaiHang) {
  return SERVICE_TYPES.indexOf(String(loaiHang || "").trim()) >= 0;
}

// ===== GET: schema report =====
function schemaReport(reqId) {
  const issues = { missingSheets: [], missingHeaders: {}, detectedHeaders: {} };
  const required = {};

  for (const sheetName in SCHEMA) {
    required[sheetName] = SCHEMA[sheetName].requiredAnyOf;

    const ws = SS.getSheetByName(sheetName);
    if (!ws) {
      issues.missingSheets.push(sheetName);
      continue;
    }

    const hs = _headers_(ws);
    issues.detectedHeaders[sheetName] = hs;

    const miss = [];
    const req = SCHEMA[sheetName].requiredAnyOf;
    for (const key in req) {
      const variants = req[key].map(x => String(x).toLowerCase());
      const ok = variants.some(v => hs.indexOf(v) >= 0);
      if (!ok) miss.push({ field: key, expectedOneOf: req[key] });
    }
    if (miss.length) issues.missingHeaders[sheetName] = miss;
  }

  return _ok_({ schema: required, issues: issues }, reqId);
}

// ===== GET: Artists =====
function getArtists() {
  const ws = _sheet_("Admin_Artists");
  const h = _hmap_(ws);
  const data = ws.getDataRange().getValues();

  const cId = _col_(h, SCHEMA.Admin_Artists.requiredAnyOf.id);
  const cName = _col_(h, SCHEMA.Admin_Artists.requiredAnyOf.name);
  const cType = _col_(h, SCHEMA.Admin_Artists.requiredAnyOf.type);
  const cRate = _col_(h, SCHEMA.Admin_Artists.requiredAnyOf.rate);

  // fallback v2.0: A=id, B=name, C=type, D=rate
  const artists = [];
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const id = (cId >= 0) ? row[cId] : row[0];
    if (!id) continue;
    artists.push({
      id: String(id),
      name: String((cName >= 0) ? row[cName] : (row[1] || "")),
      type: String((cType >= 0) ? row[cType] : (row[2] || "")),
      rate: _asNum_((cRate >= 0) ? row[cRate] : row[3], 0),
    });
  }
  return { ok: true, artists: artists, version: API_VERSION, ts: _nowStr_() };
}

function _getArtistMap_() {
  try {
    const res = getArtists();
    const map = {};
    (res.artists || []).forEach(a => { map[String(a.id)] = _asNum_(a.rate, 0); });
    return map;
  } catch (_) {
    return {};
  }
}

// ===== GET: Staff (public) =====
function getStaffPublic() {
  const ws = _sheet_("Admin_Staff");
  const h = _hmap_(ws);
  const data = ws.getDataRange().getValues();

  const cId = _col_(h, SCHEMA.Admin_Staff.requiredAnyOf.staff_id);
  const cName = _col_(h, SCHEMA.Admin_Staff.requiredAnyOf.name);
  const cRole = _col_(h, SCHEMA.Admin_Staff.requiredAnyOf.role);
  const cActive = _col_(h, SCHEMA.Admin_Staff.requiredAnyOf.active);

  // fallback v2.0: A=id B=name C=role D=active
  const staff = [];
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const id = (cId >= 0) ? row[cId] : row[0];
    if (!id) continue;

    const active = (cActive >= 0) ? row[cActive] : row[3];
    if (_isFalse_(active)) continue;

    staff.push({
      id: String(id),
      name: String((cName >= 0) ? row[cName] : (row[1] || "")),
      role: String((cRole >= 0) ? row[cRole] : (row[2] || "")),
    });
  }
  return { ok: true, staff: staff, version: API_VERSION, ts: _nowStr_() };
}

// ===== GET: Products =====
function getProducts() {
  const ws = _sheet_("Admin_Products");
  const h = _hmap_(ws);
  const data = ws.getDataRange().getValues();
  const artists = _getArtistMap_();

  const cPid = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.product_id);
  const cTen = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.ten_hang);
  const cLoai = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.loai_hang);
  const cNhom = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.nhom_hang);
  const cBrand = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.brand);
  const cPrice = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.price);
  const cCost = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.cost);
  const cQty = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.qty);
  const cImg = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.img);
  const cActive = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.active);

  // fallback v2.0 indexes: A pid, B ten, C loai, D nhom, E brand, F price, G cost, H qty, I img, J active
  const products = [];
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const pid = (cPid >= 0) ? row[cPid] : row[0];
    if (!pid) continue;

    const active = (cActive >= 0) ? row[cActive] : row[9];
    if (_isFalse_(active)) continue;

    const tenHang = String((cTen >= 0) ? row[cTen] : (row[1] || ""));
    const loaiHang = String((cLoai >= 0) ? row[cLoai] : (row[2] || ""));
    const nhomHang = String((cNhom >= 0) ? row[cNhom] : (row[3] || ""));
    const brand = String((cBrand >= 0) ? row[cBrand] : (row[4] || ""));
    const isService = _isService_(loaiHang);
    const displayName = nhomHang || tenHang || String(pid);

    const price = _asNum_((cPrice >= 0) ? row[cPrice] : row[5], 0);
    const cost = _asNum_((cCost >= 0) ? row[cCost] : row[6], 0);
    const qtyRaw = _asNum_((cQty >= 0) ? row[cQty] : row[7], 0);
    const img = String((cImg >= 0) ? row[cImg] : (row[8] || ""));

    products.push({
      id: String(pid),
      name: displayName,
      type: loaiHang,       // frontend dùng type để icon/filter
      cat: nhomHang,        // frontend dùng cat để group / icon
      brand: brand,
      price: price,
      cost: cost,
      qty: isService ? 999 : qtyRaw,
      img: img,
      rate: artists[brand] || 0,
      isService: isService,
    });
  }

  return { ok: true, count: products.length, products: products, version: API_VERSION, ts: _nowStr_() };
}

// ===== GET: Orders (recent 100) =====
function getOrders() {
  const wsO = _sheet_("Orders");
  const wsI = _sheet_("Order_Items");
  const wsP = _sheet_("Payments");

  const hO = _hmap_(wsO), hI = _hmap_(wsI), hP = _hmap_(wsP);

  // Read last 100 orders only (performance)
  const lastRowO = wsO.getLastRow();
  const lastColO = Math.max(1, wsO.getLastColumn());
  if (lastRowO < 2) return { ok: true, count: 0, orders: [], version: API_VERSION, ts: _nowStr_() };

  const startRowO = Math.max(2, lastRowO - 99);
  const oData = wsO.getRange(startRowO, 1, lastRowO - startRowO + 1, lastColO).getValues();

  // Columns (header-based preferred, fallback v2.0 indices)
  const cOid = _col_(hO, SCHEMA.Orders.requiredAnyOf.order_id);
  const cDate = _col_(hO, SCHEMA.Orders.requiredAnyOf.date);
  const cStaff = _col_(hO, SCHEMA.Orders.requiredAnyOf.staff_id);
  const cCName = _col_(hO, SCHEMA.Orders.requiredAnyOf.customer_name);
  const cCPhone = _col_(hO, SCHEMA.Orders.requiredAnyOf.customer_phone);
  const cSubtotal = _col_(hO, SCHEMA.Orders.requiredAnyOf.subtotal);
  const cItemDisc = _col_(hO, SCHEMA.Orders.requiredAnyOf.item_disc_total);
  const cBillDiscAmt = _col_(hO, SCHEMA.Orders.requiredAnyOf.bill_disc_amt);
  const cBillDiscPct = _col_(hO, SCHEMA.Orders.requiredAnyOf.bill_disc_pct);
  const cNetComm = _col_(hO, SCHEMA.Orders.requiredAnyOf.net_comm_base);
  const cCardFee = _col_(hO, SCHEMA.Orders.requiredAnyOf.card_fee_amt);
  const cShip = _col_(hO, SCHEMA.Orders.requiredAnyOf.ship_amt);
  const cGrand = _col_(hO, SCHEMA.Orders.requiredAnyOf.grand_total);
  const cNotes = _col_(hO, SCHEMA.Orders.requiredAnyOf.notes);
  const cStatus = _col_(hO, SCHEMA.Orders.requiredAnyOf.status);

  // fallback v2.0: [0..14] theo script cũ
  const orders = [];
  for (let i = 0; i < oData.length; i++) {
    const row = oData[i];

    const oid = (cOid >= 0) ? row[cOid] : row[0];
    if (!oid) continue;

    const status = String((cStatus >= 0) ? row[cStatus] : (row[14] || "ACTIVE"));
    orders.push({
      orderId: String(oid),
      date: _fmtDate_((cDate >= 0) ? row[cDate] : row[1]),
      staffId: String((cStaff >= 0) ? row[cStaff] : (row[2] || "")),
      customerName: String((cCName >= 0) ? row[cCName] : (row[3] || "")),
      customerPhone: String((cCPhone >= 0) ? row[cCPhone] : (row[4] || "")),
      subtotal: _asNum_((cSubtotal >= 0) ? row[cSubtotal] : row[5], 0),
      itemDiscTotal: _asNum_((cItemDisc >= 0) ? row[cItemDisc] : row[6], 0),
      billDiscAmt: _asNum_((cBillDiscAmt >= 0) ? row[cBillDiscAmt] : row[7], 0),
      billDiscPct: _asNum_((cBillDiscPct >= 0) ? row[cBillDiscPct] : row[8], 0),
      netCommBase: _asNum_((cNetComm >= 0) ? row[cNetComm] : row[9], 0),
      cardFeeAmt: _asNum_((cCardFee >= 0) ? row[cCardFee] : row[10], 0),
      shipAmt: _asNum_((cShip >= 0) ? row[cShip] : row[11], 0),
      grandTotal: _asNum_((cGrand >= 0) ? row[cGrand] : row[12], 0),
      notes: String((cNotes >= 0) ? row[cNotes] : (row[13] || "")),
      status: status || "ACTIVE",
      items: [],
      payments: [],
    });
  }

  const orderMap = {};
  orders.forEach(o => { orderMap[o.orderId] = o; });

  // Items: read all (OK cho MVP; nếu lớn sẽ tối ưu sau)
  const iData = wsI.getDataRange().getValues();
  // header-based / fallback v2.0 indices
  const cIOrder = _col_(hI, SCHEMA.Order_Items.requiredAnyOf.order_id);
  const cIProd = _col_(hI, SCHEMA.Order_Items.requiredAnyOf.product_id);
  const cIName = _col_(hI, SCHEMA.Order_Items.requiredAnyOf.name);
  const cIBrand = _col_(hI, SCHEMA.Order_Items.requiredAnyOf.brand);
  const cICat = _col_(hI, SCHEMA.Order_Items.requiredAnyOf.cat);
  const cIQty = _col_(hI, SCHEMA.Order_Items.requiredAnyOf.qty);
  const cIUnit = _col_(hI, SCHEMA.Order_Items.requiredAnyOf.unit_price);
  const cIDisc = _col_(hI, SCHEMA.Order_Items.requiredAnyOf.discount);
  const cINet = _col_(hI, SCHEMA.Order_Items.requiredAnyOf.line_net);
  const cIStaff = _col_(hI, SCHEMA.Order_Items.requiredAnyOf.staff_id);
  const cIRate = _col_(hI, SCHEMA.Order_Items.requiredAnyOf.rate);
  const cIComm = _col_(hI, SCHEMA.Order_Items.requiredAnyOf.comm_full);

  for (let i = 1; i < iData.length; i++) {
    const row = iData[i];
    const oid = String((cIOrder >= 0) ? row[cIOrder] : (row[1] || ""));
    const o = orderMap[oid];
    if (!o) continue;

    o.items.push({
      productId: String((cIProd >= 0) ? row[cIProd] : (row[2] || "")),
      name: String((cIName >= 0) ? row[cIName] : (row[3] || "")),
      brand: String((cIBrand >= 0) ? row[cIBrand] : (row[4] || "")),
      cat: String((cICat >= 0) ? row[cICat] : (row[5] || "")),
      qty: _asNum_((cIQty >= 0) ? row[cIQty] : row[6], 0),
      unitPrice: _asNum_((cIUnit >= 0) ? row[cIUnit] : row[7], 0),
      discount: _asNum_((cIDisc >= 0) ? row[cIDisc] : row[8], 0),
      lineNet: _asNum_((cINet >= 0) ? row[cINet] : row[9], 0),
      staffId: String((cIStaff >= 0) ? row[cIStaff] : (row[10] || "")),
      rate: _asNum_((cIRate >= 0) ? row[cIRate] : row[11], 0),
      commFull: _asNum_((cIComm >= 0) ? row[cIComm] : row[12], 0),
    });
  }

  // Payments
  const pData = wsP.getDataRange().getValues();
  const cPOrder = _col_(hP, SCHEMA.Payments.requiredAnyOf.order_id);
  const cPDate = _col_(hP, SCHEMA.Payments.requiredAnyOf.date);
  const cPMethod = _col_(hP, SCHEMA.Payments.requiredAnyOf.method);
  const cPAmount = _col_(hP, SCHEMA.Payments.requiredAnyOf.amount);
  const cPNote = _col_(hP, SCHEMA.Payments.requiredAnyOf.note);
  const cPPid = _col_(hP, SCHEMA.Payments.requiredAnyOf.payment_id);

  for (let i = 1; i < pData.length; i++) {
    const row = pData[i];
    const oid = String((cPOrder >= 0) ? row[cPOrder] : (row[1] || ""));
    const o = orderMap[oid];
    if (!o) continue;

    o.payments.push({
      paymentId: String((cPPid >= 0) ? row[cPPid] : (row[0] || "")),
      date: _fmtDate_((cPDate >= 0) ? row[cPDate] : row[2]),
      method: String((cPMethod >= 0) ? row[cPMethod] : (row[3] || "")),
      amount: _asNum_((cPAmount >= 0) ? row[cPAmount] : row[4], 0),
      note: String((cPNote >= 0) ? row[cPNote] : (row[6] || "")),
    });
  }

  // newest first (giữ như v2.0)
  return { ok: true, count: orders.length, orders: orders.reverse(), version: API_VERSION, ts: _nowStr_() };
}

// ===== POST: Submit Order (đã thêm kiểm tra tồn kho) =====
function submitOrder(body) {
  const lock = LockService.getScriptLock();
  lock.waitLock(15000);

  try {
    const wsO = _sheet_("Orders");
    const wsI = _sheet_("Order_Items");
    const wsProd = _sheet_("Admin_Products");

    _tryUnprotect_("Orders");
    _tryUnprotect_("Order_Items");
    _tryUnprotect_("Admin_Products");
    _tryUnprotect_("Admin_Stock_Log");

    const orderId = body.orderId || _nextOrderId_();
    const now = _nowStr_();
    const items = Array.isArray(body.items) ? body.items : [];
    if (!items.length) return _err_("No items in order");

    // --- KIỂM TRA TỒN KHO TRƯỚC KHI BÁN ---
    const prodData = wsProd.getDataRange().getValues();
    const prodHeaders = _headers_(wsProd);
    const prodMap = {}; // map product_id -> (rowIndex, loaiHang, qtyCol)
    const hProd = _hmap_(wsProd);
    const cPid = _col_(hProd, SCHEMA.Admin_Products.requiredAnyOf.product_id);
    const cQty = _col_(hProd, SCHEMA.Admin_Products.requiredAnyOf.qty);
    const cLoai = _col_(hProd, SCHEMA.Admin_Products.requiredAnyOf.loai_hang);

    // fallback indices nếu không tìm thấy header
    const fQty = 7, fLoai = 2;

    for (let i = 1; i < prodData.length; i++) {
      const pidIndex = (cPid >= 0) ? cPid : 0; // fallback v2.0
      const pid = String(prodData[i][pidIndex] || "").trim();
      if (!pid) continue;
      const qtyIndex = (cQty >= 0) ? cQty : fQty;
      const loaiIndex = (cLoai >= 0) ? cLoai : fLoai;
      prodMap[pid] = {
        row: i + 1,
        qty: _asNum_(prodData[i][qtyIndex], 0),
        loaiHang: String(prodData[i][loaiIndex] || "")
      };
    }

    const errors = [];
    for (const it of items) {
      const pid = String(it.productId || "").trim();
      const qty = _asNum_(it.qty, 0);
      if (!pid || qty <= 0) continue;
      const prod = prodMap[pid];
      if (!prod) {
        // Allow custom/made-to-order items (frontend uses cat:"ORDER") without stock tracking
        const cat = String(it.cat || it.type || "").trim().toUpperCase();
        const isCustom = (cat === "ORDER") || /^CUSTOM-/.test(pid) || (pid === "CUSTOM");
        if (isCustom) continue;
        errors.push("Product not found: " + pid);
        continue;
      }
      if (_isService_(prod.loaiHang)) continue; // service không cần kiểm tra tồn
      if (prod.qty < qty) {
        errors.push(`Insufficient stock for ${pid}: available ${prod.qty}, requested ${qty}`);
      }
    }
    if (errors.length > 0) {
      return _err_("Stock check failed", { errors });
    }
    // --- KẾT THÚC KIỂM TRA ---

    const baseCostTotal = _asNum_(body.subtotal, 0);
    const discountTotal = _asNum_(body.itemDiscTotal, 0) + _asNum_(body.billDiscAmt, 0);
    const netCommBase = _asNum_(body.netCommBase, 0);
    const extraFeeTotal = _asNum_(body.cardFeeAmt, 0) + _asNum_(body.shipAmt, 0);
    const grandTotal = _asNum_(body.grandTotal, 0);

    // Orders row (đúng template VJ_POS_Backend)
    _appendByHeader_(wsO, {
      order_id: orderId,
      order_date: now,
      staff_id: body.staffId || "",
      customer_name: body.customerName || "",
      customer_phone: body.customerPhone || "",
      base_cost_total: baseCostTotal,
      discount_total: discountTotal,
      net_commission_base: netCommBase,
      extra_fee_total: extraFeeTotal,
      grand_total: grandTotal,
      collected_total: 0,
      collected_for_commission: 0,
      payment_status: "UNPAID",
      commission_paid_total: 0,
      status: "ACTIVE",
    });

    // Order_Items rows
    for (let k = 0; k < items.length; k++) {
      const it = items[k] || {};
      const qty = _asNum_(it.qty, 0);
      const unit = _asNum_(it.unitPrice, 0);
      const lineBase = qty * unit;
      const disc = _asNum_(it.discount, 0);
      const lineNet = (it.lineNet !== undefined && it.lineNet !== null)
        ? _asNum_(it.lineNet, 0)
        : Math.max(0, lineBase - disc);

      _appendByHeader_(wsI, {
        order_item_id: orderId + "-" + String(k + 1).padStart(2, "0"),
        order_id: orderId,
        product_id: it.productId || "",
        product_name: it.name || "",
        brand_id: it.brand || "",
        cat: it.cat || it.category || "",
        nhom_hang: it.cat || it.category || "",
        qty: qty,
        unit_price: unit,
        line_base_cost: lineBase,
        line_discount_amount: disc,
        line_net_commission_base: lineNet,
        staff_id: body.staffId || "",
        staff_commission_rate: _asNum_(it.rate, 0),
        commission_full: _asNum_(it.commFull, 0),
        commission_paid: 0,
      });
    }

    // Stock decrement + log
    _decrementStock_(items, orderId, body.staffId || "SYSTEM");

    _tryReprotect_("Orders");
    _tryReprotect_("Order_Items");

    return { ok: true, orderId, itemCount: items.length, version: API_VERSION, ts: _nowStr_() };
  } finally {
    lock.releaseLock();
  }
}

// ===== POST: Add Payment (thay thế) =====
function addPayment(body) {
  const wsP = _sheet_("Payments");
  const wsO = _sheet_("Orders");

  _tryUnprotect_("Payments");
  _tryUnprotect_("Orders");

  const paymentId = "PAY-" + new Date().getTime();
  const now = _nowStr_();

  const amountTotal = _asNum_(body.amount, 0);
  const amountForComm = _asNum_(body.amountForComm, 0);

  _appendByHeader_(wsP, {
    payment_id: paymentId,
    order_id: body.orderId || "",
    payment_date: now,
    method: body.method || "",
    amount_total: amountTotal,
    amount_for_commission: amountForComm,
    note: body.note || "",
  });

  // Update Orders collected totals + payment_status (best-effort)
  const orderId = String(body.orderId || "");
  const row = _findRowByHeader_(wsO, ["order_id","orderid","id"], orderId);
  if (row > 0) {
    const h = _hmap_(wsO);
    const cCollected = _col_(h, ["collected_total"]);
    const cCollectedComm = _col_(h, ["collected_for_commission"]);
    const cGrand = _col_(h, ["grand_total","total"]);
    const cPayStatus = _col_(h, ["payment_status"]);

    const prevCollected = (cCollected >= 0) ? _asNum_(wsO.getRange(row, cCollected + 1).getValue(), 0) : 0;
    const prevCollectedComm = (cCollectedComm >= 0) ? _asNum_(wsO.getRange(row, cCollectedComm + 1).getValue(), 0) : 0;
    const grand = (cGrand >= 0) ? _asNum_(wsO.getRange(row, cGrand + 1).getValue(), 0) : 0;

    const newCollected = prevCollected + amountTotal;
    const newCollectedComm = prevCollectedComm + amountForComm;

    if (cCollected >= 0) wsO.getRange(row, cCollected + 1).setValue(newCollected);
    if (cCollectedComm >= 0) wsO.getRange(row, cCollectedComm + 1).setValue(newCollectedComm);

    if (cPayStatus >= 0) {
      const status = (grand > 0 && newCollected >= grand) ? "PAID" : (newCollected > 0 ? "PARTIAL" : "UNPAID");
      wsO.getRange(row, cPayStatus + 1).setValue(status);
    }
  }

  _tryReprotect_("Payments");
  _tryReprotect_("Orders");

  return { ok: true, paymentId, version: API_VERSION, ts: _nowStr_() };
}

// ===== POST: Void Order (đã sửa dùng header map) =====
function voidOrder(body) {
  const role = String(body.staffRole || "").toLowerCase().trim();
  if (role !== "manager") return _err_("Only managers can void orders");

  const orderId = String(body.orderId || "").trim();
  if (!orderId) return _err_("orderId required");

  const wsO = _sheet_("Orders");
  const wsI = _sheet_("Order_Items");
  const wsProd = _sheet_("Admin_Products");

  _tryUnprotect_("Orders");
  _tryUnprotect_("Order_Items");
  _tryUnprotect_("Admin_Products");
  _tryUnprotect_("Admin_Stock_Log");

  const rowO = _findRowByHeader_(wsO, ["order_id","orderid","id"], orderId);
  if (rowO < 0) return _err_("Order not found");

  // set status = VOID
  const hO = _hmap_(wsO);
  const cStatus = _col_(hO, ["status"]);
  if (cStatus >= 0) {
    const cur = String(wsO.getRange(rowO, cStatus + 1).getValue() || "");
    if (cur === "VOID") return { ok: true, orderId, status: "VOID", already: true, version: API_VERSION, ts: _nowStr_() };
    wsO.getRange(rowO, cStatus + 1).setValue("VOID");
  }

  // Build product row map by product_id (dùng header map)
  const prodData = wsProd.getDataRange().getValues();
  const hProd = _hmap_(wsProd);
  const cProdId = _col_(hProd, SCHEMA.Admin_Products.requiredAnyOf.product_id);
  const cLoai = _col_(hProd, SCHEMA.Admin_Products.requiredAnyOf.loai_hang);
  const cQty = _col_(hProd, SCHEMA.Admin_Products.requiredAnyOf.qty);

  // fallback indices nếu không tìm thấy header
  const fProdId = 0, fLoai = 2, fQty = 7;

  const prodMap = {};
  for (let i = 1; i < prodData.length; i++) {
    const pid = String((cProdId >= 0) ? prodData[i][cProdId] : prodData[i][fProdId] || "");
    if (pid) {
      prodMap[pid] = {
        row: i + 1,
        loaiHang: String((cLoai >= 0) ? prodData[i][cLoai] : prodData[i][fLoai] || ""),
        qtyCol: (cQty >= 0) ? cQty : fQty
      };
    }
  }

  // Restore stock from Order_Items
  const iData = wsI.getDataRange().getValues();
  const hI = _hmap_(wsI);
  const cIOrder = _col_(hI, ["order_id","orderid"]);
  const cIProd = _col_(hI, ["product_id","productid"]);
  const cIQty = _col_(hI, ["qty","quantity"]);

  for (let i = 1; i < iData.length; i++) {
    const row = iData[i];
    if (String(row[cIOrder]) !== orderId) continue;

    const pid = String(row[cIProd] || "");
    const qty = _asNum_(row[cIQty], 0);
    const prod = prodMap[pid];
    if (!prod || qty <= 0) continue;

    // skip service
    if (_isService_(prod.loaiHang)) continue;

    const qtyBefore = _asNum_(wsProd.getRange(prod.row, prod.qtyCol + 1).getValue(), 0);
    const qtyAfter = qtyBefore + qty;
    wsProd.getRange(prod.row, prod.qtyCol + 1).setValue(qtyAfter);

    _logStock_(pid, "VOID_RESTORE", qty, qtyBefore, qtyAfter, orderId, body.staffId || "SYSTEM");
  }

  _tryReprotect_("Orders");
  return { ok: true, orderId, status: "VOID", version: API_VERSION, ts: _nowStr_() };
}

// ===== POST: Update Stock (manual adjustment) =====
function updateStock(body) {
  const productId = String(body.productId || "").trim();
  const qtyChange = _asNum_(body.qtyChange, 0);
  if (!productId) return _err_("productId required");

  const ws = _sheet_("Admin_Products");
  _tryUnprotect_("Admin_Products");
  _tryUnprotect_("Admin_Stock_Log");

  const h = _hmap_(ws);
  const cQty = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.qty);
  const qtyCol = (cQty >= 0) ? (cQty + 1) : 8; // fallback v2.0: cột H (index 7)

  // Find row by product_id header (fallback: cột A)
  const row = _findRowByHeader_(ws, SCHEMA.Admin_Products.requiredAnyOf.product_id, productId);
  if (row > 0) {
    const qtyBefore = _asNum_(ws.getRange(row, qtyCol).getValue(), 0);
    const qtyAfter = qtyBefore + qtyChange;
    ws.getRange(row, qtyCol).setValue(qtyAfter);

    _logStock_(productId, body.changeType || "ADJUSTMENT", qtyChange, qtyBefore, qtyAfter, body.reference || "", body.staffId || "MANUAL");
    return { ok: true, productId: productId, qtyBefore: qtyBefore, qtyAfter: qtyAfter, version: API_VERSION, ts: _nowStr_() };
  }
  return _err_("Product not found: " + productId);
}
// ===== POST: Bulk Import (manager only) – đã sửa getMaxColumns() =====
function bulkImport(body) {
  const role = String(body.staffRole || "").toLowerCase().trim();
  if (role !== "manager") return _err_("Only managers can import stock");

  const items = Array.isArray(body.items) ? body.items : [];
  if (!items.length) return _err_("No items to import");

  const ws = _sheet_("Admin_Products");
  _tryUnprotect_("Admin_Products");
  _tryUnprotect_("Admin_Stock_Log");

  const h = _hmap_(ws);
  const cPid = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.product_id);
  const cTen = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.ten_hang);
  const cLoai = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.loai_hang);
  const cNhom = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.nhom_hang);
  const cBrand = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.brand);
  const cPrice = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.price);
  const cCost = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.cost);
  const cQty = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.qty);
  const cImg = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.img);
  const cActive = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.active);

  // Fallback indexes (v2.0)
  const fPid = 0, fTen = 1, fLoai = 2, fNhom = 3, fBrand = 4, fPrice = 5, fCost = 6, fQty = 7, fImg = 8, fActive = 9;

  const data = ws.getDataRange().getValues();
  const existingMap = {};
  for (let i = 1; i < data.length; i++) {
    const pid = String((cPid >= 0) ? data[i][cPid] : data[i][fPid] || "");
    if (pid) existingMap[pid] = i + 1;
  }

  let updated = 0, added = 0;
  const errors = [];

  for (const it of items) {
    const pid = String(it.product_id || it.productId || "").trim();
    if (!pid) { errors.push("Missing product_id"); continue; }

    const qtyToAdd = _asNum_(it.qty_add ?? it.qty_to_add ?? it.qtyAdd ?? 0, 0);
    const price = (it.price !== undefined && it.price !== null) ? _asNum_(it.price, 0) : null;
    const cost = (it.cost !== undefined && it.cost !== null) ? _asNum_(it.cost, 0) : null;

    const rowNum = existingMap[pid];

    if (rowNum) {
      // Update existing: add qty
      if (qtyToAdd !== 0) {
        const qtyBefore = _asNum_(ws.getRange(rowNum, (cQty >= 0 ? cQty + 1 : fQty + 1)).getValue(), 0);
        const qtyAfter = qtyBefore + qtyToAdd;
        ws.getRange(rowNum, (cQty >= 0 ? cQty + 1 : fQty + 1)).setValue(qtyAfter);
        _logStock_(pid, "IMPORT", qtyToAdd, qtyBefore, qtyAfter, "BULK_IMPORT", body.staffId || "SYSTEM");
        updated++;
      }
      // Update price/cost if provided
      if (price !== null) ws.getRange(rowNum, (cPrice >= 0 ? cPrice + 1 : fPrice + 1)).setValue(price);
      if (cost !== null) ws.getRange(rowNum, (cCost >= 0 ? cCost + 1 : fCost + 1)).setValue(cost);
    } else {
      // Add new product (require name)
      const name = String(it.name || "").trim();
      if (!name) { errors.push(pid + ": missing name"); continue; }

      // Lấy tổng số cột hiện tại của sheet (kể cả cột trống cuối cùng)
      const maxCols = ws.getMaxColumns();
      const row = new Array(maxCols).fill("");

      // Fill by header if possible, else fallback layout
      if (cPid >= 0) row[cPid] = pid; else row[fPid] = pid;
      if (cTen >= 0) row[cTen] = it.ten_hang || "Hàng hóa"; else row[fTen] = it.ten_hang || "Hàng hóa";
      if (cLoai >= 0) row[cLoai] = it.type || ""; else row[fLoai] = it.type || "";
      if (cNhom >= 0) row[cNhom] = name; else row[fNhom] = name;
      if (cBrand >= 0) row[cBrand] = it.brand || ""; else row[fBrand] = it.brand || "";
      if (cPrice >= 0) row[cPrice] = _asNum_(it.price, 0); else row[fPrice] = _asNum_(it.price, 0);
      if (cCost >= 0) row[cCost] = _asNum_(it.cost, 0); else row[fCost] = _asNum_(it.cost, 0);
      if (cQty >= 0) row[cQty] = qtyToAdd; else row[fQty] = qtyToAdd;
      if (cImg >= 0) row[cImg] = it.image_url || ""; else row[fImg] = it.image_url || "";
      if (cActive >= 0) row[cActive] = true; else row[fActive] = true;

      ws.appendRow(row);
      _logStock_(pid, "NEW_PRODUCT", qtyToAdd, 0, qtyToAdd, "BULK_IMPORT", body.staffId || "SYSTEM");
      added++;
    }
  }

  return { ok: true, updated: updated, added: added, errors: errors, version: API_VERSION, ts: _nowStr_() };
}

// ===== Order id generator (locked by submitOrder lock) =====
function _nextOrderId_() {
  const ws = _sheet_("Orders");
  const lastRow = ws.getLastRow();
  if (lastRow <= 1) return "VJ-0001";
  const lastId = String(ws.getRange(lastRow, 1).getValue() || "");
  const num = parseInt(lastId.replace(/\D/g, ""), 10) || 0;
  return "VJ-" + String(num + 1).padStart(4, "0");
}

// ===== Stock decrement (SALE) =====
function _decrementStock_(items, orderId, changedBy) {
  const ws = _sheet_("Admin_Products");
  const data = ws.getDataRange().getValues();

  const h = _hmap_(ws);
  const cPid = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.product_id);
  const cLoai = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.loai_hang);
  const cQty = _col_(h, SCHEMA.Admin_Products.requiredAnyOf.qty);

  // Fallback layout v2.0 nếu sheet không có header đúng
  const fPid = 0, fLoai = 2, fQty = 7;

  const pidIndex = (cPid >= 0) ? cPid : fPid;
  const loaiIndex = (cLoai >= 0) ? cLoai : fLoai;
  const qtyCol = (cQty >= 0) ? (cQty + 1) : (fQty + 1);

  // Build map productId -> sheet row number (1-based)
  const rowMap = {};
  for (let i = 1; i < data.length; i++) {
    const pid = String(data[i][pidIndex] || "").trim();
    if (pid) rowMap[pid] = i + 1;
  }

  for (const item of items) {
    const pid = String(item.productId || "").trim();
    const qty = _asNum_(item.qty, 0);
    if (!pid || qty <= 0) continue;

    const sheetRow = rowMap[pid];
    if (!sheetRow) continue;

    const loaiHang = String(data[sheetRow - 1][loaiIndex] || "");
    if (_isService_(loaiHang)) continue;

    const qtyBefore = _asNum_(ws.getRange(sheetRow, qtyCol).getValue(), 0);
    const qtyAfter = Math.max(0, qtyBefore - qty);
    ws.getRange(sheetRow, qtyCol).setValue(qtyAfter);

    _logStock_(pid, "SALE", -qty, qtyBefore, qtyAfter, orderId, changedBy || "SYSTEM");
  }
}
// ===== Stock log =====
function _logStock_(productId, changeType, qtyChange, qtyBefore, qtyAfter, reference, changedBy) {
  // Nếu thiếu sheet log, bỏ qua thay vì làm fail nghiệp vụ
  const ws = SS.getSheetByName("Admin_Stock_Log");
  if (!ws) return;

  _tryUnprotect_("Admin_Stock_Log");

  const logId = "LOG-" + new Date().getTime() + "-" + Math.random().toString(36).substr(2, 4);
  const now = _nowStr_();
  ws.appendRow([logId, now, productId, changeType, qtyChange, qtyBefore, qtyAfter, reference, changedBy]);

  _tryReprotect_("Admin_Stock_Log");
}

function _fmtDate_(d) {
  if (!d) return "";
  if (d instanceof Date) return Utilities.formatDate(d, TZ, "yyyy-MM-dd HH:mm:ss");
  return String(d);
}

// ===== Sheet protection (best-effort, không làm fail nghiệp vụ) =====
function _tryUnprotect_(name) {
  try {
    const ws = SS.getSheetByName(name);
    if (!ws) return;
    const protections = ws.getProtections(SpreadsheetApp.ProtectionType.SHEET);
    for (const p of protections) p.remove();
  } catch (_) {}
}

function _tryReprotect_(name) {
  try {
    const ws = SS.getSheetByName(name);
    if (!ws) return;
    const protection = ws.protect().setDescription("VJ-POS locked: " + name);
    protection.setWarningOnly(true);
  } catch (_) {}
}

// ===== Debug helpers (optional) =====
function testSchema() {
  Logger.log(JSON.stringify(schemaReport(), null, 2));
}
